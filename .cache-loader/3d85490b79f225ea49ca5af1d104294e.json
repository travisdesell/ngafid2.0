{"remainingRequest":"/ngafid/ngafid2.0/node_modules/babel-loader/lib/index.js??ruleSet[1].rules[0].use[1]!/ngafid/ngafid2.0/src/main/javascript/map_utils.js","dependencies":[{"path":"/ngafid/ngafid2.0/src/main/javascript/map_utils.js","mtime":1664810261290},{"path":"/ngafid/ngafid2.0/.babelrc","mtime":1664810261182},{"path":"/ngafid/ngafid2.0/node_modules/cache-loader/dist/cjs.js","mtime":1664910647113},{"path":"/ngafid/ngafid2.0/node_modules/babel-loader/lib/index.js","mtime":1664910647213}],"contextDependencies":[],"result":["//Static class to assist with generation of LOC-I Index and Stall Index 'heatmaps'\nimport { Vector as VectorSource } from 'ol/source.js';\nimport { Group, Vector as VectorLayer } from 'ol/layer.js';\nimport { Circle, Fill, Icon, Stroke, Style } from 'ol/style.js';\nimport Feature from 'ol/Feature.js';\nimport LineString from 'ol/geom/LineString.js'; // So the weights w0 and w1 are for the weighted average\n// They should add to 1.0 so if one of them is 0, the resulting color\n// will just be the other color (e.g. w0 is 0 then the resulting color will be the same as c1)\n\nfunction interpolateColors(c0, w0, c1, w1) {\n  var new_color = [0.0, 0.0, 0.0]; // red = 0, green = 1, blue = 2\n\n  for (var i = 0; i < 3; i++) {\n    new_color[i] = Math.round(w0 * c0[i] + w1 * c1[i]);\n  }\n\n  return new_color;\n} // loc_percentage should be between 0 and 1.0\n// This will get the color for a given p(LOC)\n// This can probably be made cleaner / not use if statements and just use lists but im lazy\n\n\nfunction paletteAt(loc_probability) {\n  if (loc_probability < 0.8) {\n    var c0 = [0, 255, 0]; // green\n\n    var c1 = [255, 255, 0]; // yellow\n    // This will be a proportion between 0 and 1 since the max value for loc_p = 0.8 and min is 0\n\n    var weight = loc_probability / 0.8;\n    var w0 = 1.0 - weight; // if weight is 1, we want there to be no green and all yellow\n\n    var w1 = weight;\n    return interpolateColors(c0, w0, c1, w1);\n  } else if (loc_probability >= 0.8 && loc_probability < 1.0) {\n    // Our range of loc_p values is 0.8 to 1.0, so a distance of 0.2\n    var c0 = [255, 255, 0]; //yellow\n\n    var c1 = [255, 0, 0]; //red\n    // The minimum value of this will be 0.0 and max is 0.2\n\n    var numerator = loc_probability - 0.8; // value range is 0.0 to 1.0\n\n    var weight = numerator / 0.2;\n    var w0 = 1.0 - weight;\n    var w1 = weight;\n    return interpolateColors(c0, w0, c1, w1);\n  } else {\n    // red\n    return [255, 0, 0];\n  }\n}\n\nfunction paletteGenerator(colors, pos) {\n  return function (p) {\n    var length = colors.length;\n\n    for (var i = 0; i < length - 1; i++) {\n      if (p <= pos[i + 1]) {\n        var diff = pos[i + 1] - pos[i];\n        var w0 = 1 - (p - pos[i]) / diff;\n        var w1 = 1 - (pos[i + 1] - p) / diff;\n        return interpolateColors(colors[i], w0, colors[i + 1], w1);\n      }\n    }\n\n    return colors[length - 1];\n  };\n}\n/**\n * Generates the layer for Stall Index\n *\n * @param spData the DoubleTimeSeries with the stall index data\n * @param layers the collection of layers to add this new layer to\n * @param flight the flight object that has data pertaining to the flight\n */\n\n\nfunction generateStallLayer(spData, layers, flight) {\n  var spPhases = [],\n      spOutlinePhases = [];\n\n  if (spData != null) {\n    for (var i = 0; i < spData.length; i++) {\n      var val = spData[i];\n      var feat = new Feature({\n        geometry: new LineString(flight.state.points.slice(i, i + 2)),\n        name: \"SP\"\n      });\n      feat.setId(i);\n      feat.parent = 'Stall Index';\n      feat.setStyle([new Style({\n        stroke: new Stroke({\n          color: paletteAt(val),\n          width: 8\n        })\n      })]);\n      var outFeat = new Feature({\n        geometry: new LineString(flight.state.points.slice(i, i + 2)),\n        name: \"Stall Index Outline\"\n      });\n      outFeat.setId(i);\n      outFeat.parent = 'Stall Index';\n      spOutlinePhases.push(outFeat);\n      spPhases.push(feat);\n    }\n  }\n\n  spPhases.push(flight.state.trackingPoint);\n  var spLayer = new VectorLayer({\n    name: 'Stall Index',\n    description: 'Stall Index',\n    nMap: false,\n    disabled: spData == null,\n    source: new VectorSource({\n      features: spPhases\n    })\n  });\n  var spLayerOutline = new VectorLayer({\n    name: 'Stall Index',\n    description: 'Stall Index Outline',\n    nMap: true,\n    disabled: spData == null,\n    style: new Style({\n      stroke: new Stroke({\n        color: flight.state.color,\n        width: 12\n      })\n    }),\n    source: new VectorSource({\n      features: spOutlinePhases\n    })\n  });\n  spLayer.flightState = flight;\n  layers.push(spLayerOutline, spLayer);\n}\n/**\n * Generates the layer for LOC-I Index\n *\n * @param spData the DoubleTimeSeries with the LOC-I index data\n * @param layers the collection of layers to add this new layer to\n * @param flight the flight object that has data pertaining to the flight\n */\n\n\nfunction generateLOCILayer(lociData, layers, flight) {\n  var lociPhases = [],\n      lociOutlinePhases = [];\n\n  if (lociData != null) {\n    for (var i = 0; i < lociData.length; i++) {\n      var val = lociData[i];\n      var feat = new Feature({\n        geometry: new LineString(flight.state.points.slice(i, i + 2)),\n        name: \"LOC-I Index\"\n      });\n      feat.setId(i);\n      feat.parent = 'LOC-I Index';\n      feat.setStyle([new Style({\n        stroke: new Stroke({\n          color: paletteAt(val),\n          width: 8\n        })\n      })]);\n      var outFeat = new Feature({\n        geometry: new LineString(flight.state.points.slice(i, i + 2)),\n        name: \"LOC-I Index Outline\"\n      });\n      outFeat.setId(i);\n      outFeat.parent = 'LOC-I Index';\n      lociPhases.push(feat);\n      lociOutlinePhases.push(outFeat);\n    }\n  }\n\n  lociPhases.push(flight.state.trackingPoint);\n  var lociLayer = new VectorLayer({\n    name: 'LOC-I Index',\n    description: 'LOC-I Index',\n    nMap: false,\n    disabled: lociData == null,\n    source: new VectorSource({\n      features: lociPhases\n    })\n  });\n  var lociLayerOutline = new VectorLayer({\n    name: 'LOC-I Index Outline',\n    description: 'LOC-I Index',\n    nMap: true,\n    disabled: lociData == null,\n    style: new Style({\n      stroke: new Stroke({\n        color: flight.state.color,\n        width: 12\n      })\n    }),\n    source: new VectorSource({\n      features: lociOutlinePhases\n    })\n  });\n  lociLayer.flightState = flight;\n  layers.push(lociLayerOutline, lociLayer);\n}\n\nexport { generateStallLayer, generateLOCILayer, paletteAt, paletteGenerator };",{"version":3,"names":["Vector","VectorSource","Group","VectorLayer","Circle","Fill","Icon","Stroke","Style","Feature","LineString","interpolateColors","c0","w0","c1","w1","new_color","i","Math","round","paletteAt","loc_probability","weight","numerator","paletteGenerator","colors","pos","p","length","diff","generateStallLayer","spData","layers","flight","spPhases","spOutlinePhases","val","feat","geometry","state","points","slice","name","setId","parent","setStyle","stroke","color","width","outFeat","push","trackingPoint","spLayer","description","nMap","disabled","source","features","spLayerOutline","style","flightState","generateLOCILayer","lociData","lociPhases","lociOutlinePhases","lociLayer","lociLayerOutline"],"sources":["/ngafid/ngafid2.0/src/main/javascript/map_utils.js"],"sourcesContent":["//Static class to assist with generation of LOC-I Index and Stall Index 'heatmaps'\nimport {Vector as VectorSource} from 'ol/source.js';\nimport {Group, Vector as VectorLayer} from 'ol/layer.js';\nimport {Circle, Fill, Icon, Stroke, Style} from 'ol/style.js';\nimport Feature from 'ol/Feature.js';\nimport LineString from 'ol/geom/LineString.js';\n\n\n// So the weights w0 and w1 are for the weighted average\n// They should add to 1.0 so if one of them is 0, the resulting color\n// will just be the other color (e.g. w0 is 0 then the resulting color will be the same as c1)\nfunction interpolateColors(c0, w0, c1, w1) {\n    var new_color = [0.0, 0.0, 0.0];\n    // red = 0, green = 1, blue = 2\n    for (var i = 0; i < 3; i++) {\n        new_color[i] = Math.round(w0 * c0[i] + w1 * c1[i]);\n    }\n    return new_color;\n}\n\n// loc_percentage should be between 0 and 1.0\n// This will get the color for a given p(LOC)\n// This can probably be made cleaner / not use if statements and just use lists but im lazy\nfunction paletteAt(loc_probability) {\n    if (loc_probability < 0.8) {\n        var c0 = [0, 255, 0]; // green\n        var c1 = [255, 255, 0]; // yellow\n\n        // This will be a proportion between 0 and 1 since the max value for loc_p = 0.8 and min is 0\n        var weight = loc_probability / 0.8;\n        var w0 = 1.0 - weight; // if weight is 1, we want there to be no green and all yellow\n        var w1 = weight;\n\n        return interpolateColors(c0, w0, c1, w1);\n    } else if (loc_probability >= 0.8 && loc_probability < 1.0) {\n        // Our range of loc_p values is 0.8 to 1.0, so a distance of 0.2\n        var c0 = [255, 255, 0];//yellow\n        var c1 = [255, 0, 0];//red\n\n        // The minimum value of this will be 0.0 and max is 0.2\n        var numerator = loc_probability - 0.8;\n\n        // value range is 0.0 to 1.0\n        var weight = numerator / 0.2;\n        var w0 = 1.0 - weight;\n        var w1 = weight;\n\n        return interpolateColors(c0, w0, c1, w1);\n    } else {\n        // red\n        return [255, 0, 0];\n    }\n}\n\n\nfunction paletteGenerator(colors, pos) {\n    return function (p) {\n        let length = colors.length;\n        for (var i = 0; i < length - 1; i++) {\n            if (p <= pos[i + 1]) {\n                let diff = pos[i + 1] - pos[i];\n                let w0 = 1 - (p - pos[i]) / diff;\n                let w1 = 1 - (pos[i + 1] - p) / diff;\n                return interpolateColors(colors[i], w0, colors[i + 1], w1);\n            }\n        }\n        return colors[length - 1];\n    }\n}\n\n/**\n * Generates the layer for Stall Index\n *\n * @param spData the DoubleTimeSeries with the stall index data\n * @param layers the collection of layers to add this new layer to\n * @param flight the flight object that has data pertaining to the flight\n */\nfunction generateStallLayer(spData, layers, flight) {\n    var spPhases = [], spOutlinePhases = [];\n    if (spData != null) {\n        for(let i = 0; i < spData.length; i++){\n            let val = spData[i];\n            var feat = new Feature({\n                geometry : new LineString(flight.state.points.slice(i, i+2)),\n                name : \"SP\"\n            });\n            feat.setId(i);\n            feat.parent = 'Stall Index';\n            feat.setStyle([\n              new Style({\n                stroke: new Stroke({\n                  color: paletteAt(val),\n                  width: 8\n                })\n              })\n            ]);\n\n            let outFeat = new Feature({\n                geometry : new LineString(flight.state.points.slice(i, i+2)),\n                name : \"Stall Index Outline\"\n            });\n\n            outFeat.setId(i);\n            outFeat.parent = 'Stall Index';\n\n            spOutlinePhases.push(outFeat);\n            spPhases.push(feat);\n        }\n    }\n\n    spPhases.push(flight.state.trackingPoint);\n\n    let spLayer = new VectorLayer({\n        name : 'Stall Index' ,\n        description : 'Stall Index',\n        nMap : false,\n        disabled : (spData == null),\n        source : new VectorSource({\n            features: spPhases                        \n        })\n    });\n\n    let spLayerOutline = new VectorLayer({\n        name : 'Stall Index' ,\n        description : 'Stall Index Outline',\n        nMap : true,\n        disabled : (spData == null),\n        style : new Style({\n            stroke: new Stroke({\n                color: flight.state.color,\n                width : 12\n\n            })\n        }),\n        source : new VectorSource({\n            features: spOutlinePhases                        \n        })\n    });\n\n    spLayer.flightState = flight;\n    layers.push(spLayerOutline, spLayer);\n}\n\n/**\n * Generates the layer for LOC-I Index\n *\n * @param spData the DoubleTimeSeries with the LOC-I index data\n * @param layers the collection of layers to add this new layer to\n * @param flight the flight object that has data pertaining to the flight\n */\nfunction generateLOCILayer(lociData, layers, flight) {\n    var lociPhases = [], lociOutlinePhases = [];\n    if (lociData != null) {\n        for(let i = 0; i < lociData.length; i++){\n            let val = lociData[i];\n            var feat = new Feature({\n                geometry : new LineString(flight.state.points.slice(i, i+2)),\n                name : \"LOC-I Index\"\n            });\n            feat.setId(i);\n            feat.parent = 'LOC-I Index';\n            feat.setStyle([\n              new Style({\n                stroke: new Stroke({\n                  color: paletteAt(val),\n                  width: 8\n                })\n              })\n            ]);\n\n            let outFeat = new Feature({\n                geometry : new LineString(flight.state.points.slice(i, i+2)),\n                name : \"LOC-I Index Outline\"\n            });\n\n            outFeat.setId(i);\n            outFeat.parent = 'LOC-I Index';\n\n            lociPhases.push(feat);\n            lociOutlinePhases.push(outFeat);\n        }\n    }\n\n\n    lociPhases.push(flight.state.trackingPoint);\n\n    let lociLayer = new VectorLayer({\n        name : 'LOC-I Index' ,\n        description : 'LOC-I Index' ,\n        nMap : false,\n        disabled : (lociData == null),\n\n        source : new VectorSource({\n            features: lociPhases\n        })\n    });\n\n    let lociLayerOutline = new VectorLayer({\n        name : 'LOC-I Index Outline' ,\n        description : 'LOC-I Index' ,\n        nMap : true,\n        disabled : (lociData == null),\n        style : new Style({\n            stroke: new Stroke({\n                color: flight.state.color,\n                width : 12\n            })\n        }),\n        source : new VectorSource({\n            features: lociOutlinePhases                        \n        })\n    });\n\n\n    lociLayer.flightState = flight;\n    layers.push(lociLayerOutline, lociLayer);\n}\n\nexport {generateStallLayer, generateLOCILayer, paletteAt, paletteGenerator };\n"],"mappings":"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"}]}