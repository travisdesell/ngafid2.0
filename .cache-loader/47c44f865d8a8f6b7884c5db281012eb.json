{"remainingRequest":"/ngafid/ngafid2.0/node_modules/babel-loader/lib/index.js??ruleSet[1].rules[0].use[1]!/ngafid/ngafid2.0/src/main/javascript/ttf.js","dependencies":[{"path":"/ngafid/ngafid2.0/src/main/javascript/ttf.js","mtime":1664810261290},{"path":"/ngafid/ngafid2.0/.babelrc","mtime":1664810261182},{"path":"/ngafid/ngafid2.0/node_modules/cache-loader/dist/cjs.js","mtime":1664910647113},{"path":"/ngafid/ngafid2.0/node_modules/babel-loader/lib/index.js","mtime":1664910647213}],"contextDependencies":[],"result":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport 'bootstrap';\nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Form from \"react-bootstrap/Form\";\nimport { map, styles, layers, Colors, overlay, initializeMap, container, content, closer } from \"./map.js\";\nimport { TimeHeader, TurnToFinalHeaderComponents } from \"./time_header.js\";\nimport SignedInNavbar from \"./signed_in_navbar.js\";\nimport { paletteAt, paletteGenerator } from \"./map_utils.js\";\nimport View from 'ol/View';\nimport Overlay from 'ol/Overlay';\nimport Coordinate from 'ol/coordinate';\nimport { fromLonLat, toLonLat } from 'ol/proj.js';\nimport { Group, Vector as VectorLayer } from 'ol/layer.js';\nimport { Vector as VectorSource } from 'ol/source.js';\nimport { Circle, Fill, Icon, Stroke, Style } from 'ol/style.js';\nimport Draw from 'ol/interaction/Draw.js';\nimport Feature from 'ol/Feature.js';\nimport LineString from 'ol/geom/LineString.js';\nimport Point from 'ol/geom/Point.js';\nimport { Filter } from './filter.js';\nimport Plotly from 'plotly.js';\n\nvar moment = require('moment');\n\ninitializeMap();\n\nvar RollSlider = /*#__PURE__*/function (_React$Component) {\n  _inherits(RollSlider, _React$Component);\n\n  var _super = _createSuper(RollSlider);\n\n  function RollSlider(props) {\n    _classCallCheck(this, RollSlider);\n\n    return _super.call(this, props);\n  }\n\n  _createClass(RollSlider, [{\n    key: \"makeRollSlider\",\n    value: function makeRollSlider(min, max, onChange, getValue) {\n      var _React$createElement;\n\n      return /*#__PURE__*/React.createElement(\"div\", {\n        className: \"col-auto\",\n        style: {\n          textAlign: 'center',\n          margin: 'auto'\n        }\n      }, \"Minimum Roll Value = \", getValue(), \"\\xB0  \", /*#__PURE__*/React.createElement(\"br\", null), min, \"\\xB0 \", /*#__PURE__*/React.createElement(\"input\", (_React$createElement = {\n        id: \"rollSlider\",\n        type: \"range\",\n        min: min,\n        max: max,\n        value: getValue(),\n        className: \"slider\"\n      }, _defineProperty(_React$createElement, \"id\", \"rollSlider\"), _defineProperty(_React$createElement, \"onInput\", function onInput(val) {\n        return onChange(val);\n      }), _defineProperty(_React$createElement, \"style\", {\n        margin: 'auto',\n        verticalAlign: 'middle'\n      }), _React$createElement)), \" \", max, \"\\xB0\", /*#__PURE__*/React.createElement(\"br\", null), /*#__PURE__*/React.createElement(\"div\", {\n        style: {\n          margin: \"auto\",\n          width: \"83%\",\n          backgroundImage: \"linear-gradient(90deg, rgb(0, 255, 0), 55%, rgb(255, 255, 0), 66%, rgb(255, 0, 0))\",\n          height: \"4px\"\n        }\n      }));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.makeRollSlider(this.props.rollSliderMin, this.props.rollSliderMax, this.props.rollSliderChanged, this.props.rollSliderValue);\n    }\n  }]);\n\n  return RollSlider;\n}(React.Component);\n\nvar rollPalette = paletteGenerator([[0, 255, 0], [255, 255, 0], [255, 0, 0]], [0, 26, 30]); // Default chart layout, used for empty charts\n\nvar plotlyDefaultLayout = {\n  title: 'Chart',\n  showlegend: true,\n  autosize: true,\n  margin: {\n    pad: 2\n  },\n  xaxis: {\n    title: {\n      text: 'Time (Seconds)',\n      font: {\n        family: 'sans serif',\n        size: 18,\n        color: '#000000'\n      }\n    }\n  },\n  yaxis: {\n    title: {\n      text: 'Self Defined Glide Angle',\n      font: {\n        family: 'sans serif',\n        size: 18,\n        color: '#000000'\n      }\n    }\n  }\n};\nvar glideAngleHistLayout = {\n  title: 'Histogram of Glide Path Angles',\n  bargap: 0.05,\n  showlegend: true,\n  autosize: true,\n  margin: {\n    pad: 10\n  },\n  xaxis: {\n    title: 'Frequency'\n  },\n  yaxis: {\n    title: 'Glide Path Angle'\n  }\n};\nvar deviationsPlotlyLayout = {\n  title: 'Glide Path Deviations',\n  showlegend: true,\n  autosize: true,\n  margin: {\n    pad: 2\n  },\n  xaxis: {\n    title: {\n      text: 'Distance from Runway (ft.)',\n      font: {\n        family: 'sans serif',\n        size: 18,\n        color: '#000000'\n      }\n    },\n    autorange: \"reversed\"\n  },\n  yaxis: {\n    title: {\n      text: 'Distance above Glidepath (ft.)',\n      font: {\n        family: 'sans serif',\n        size: 18,\n        color: '#000000'\n      },\n      range: [-100, 100]\n    }\n  }\n};\nvar altitudePlotlyLayout = {\n  title: 'Altitude vs. Distance to Runway',\n  showlegend: true,\n  autosize: true,\n  margin: {\n    pad: 2\n  },\n  xaxis: {\n    title: {\n      text: 'Distance from Runway (ft.)',\n      font: {\n        family: 'sans serif',\n        size: 18,\n        color: '#000000'\n      }\n    },\n    autorange: \"reversed\"\n  },\n  yaxis: {\n    title: {\n      text: 'Alitude (AGL) (ft.)',\n      font: {\n        family: 'sans serif',\n        size: 18,\n        color: '#000000'\n      }\n    }\n  }\n};\nvar plotlyConfig = {\n  responsive: true\n};\n\nvar TTFCard = /*#__PURE__*/function (_React$Component2) {\n  _inherits(TTFCard, _React$Component2);\n\n  var _super2 = _createSuper(TTFCard);\n\n  function TTFCard(props) {\n    var _this;\n\n    _classCallCheck(this, TTFCard);\n\n    _this = _super2.call(this, props);\n    var date = new Date();\n    _this.state = {\n      // The start of the date range that this.state.data corresponds to.\n      // This will be null if and only if this.state.data is null\n      dataStartDate: null,\n      // The end of the date range that this.state.data corresponds to.\n      // This will be null if and only if this.state.data is null\n      dataEndDate: null,\n      // Data is an object containing the following information:\n      //     data = {\n      //         airports: [ <list of airports that appear in the ttf list> ],\n      //         ttfs: [ <list of turn to final objects> ],\n      //     }\n      // The turn to final objects are defined in the org.ngafid.flights.TurnToFinal::jsonify method.\n      data: null,\n      datesChanged: true,\n      minRoll: 25.0,\n      startYear: 2000,\n      startMonth: 1,\n      endYear: date.getFullYear(),\n      endMonth: date.getMonth() + 1,\n      startDate: \"2000-01-01\",\n      startDateObject: _this.parseDate(\"2000-01-01\"),\n      endDate: new String(date.getFullYear()) + \"-\" + (date.getMonth() + 1) + \"-01\",\n      endDateObject: _this.parseDate(new String(date.getFullYear()) + \"-\" + (date.getMonth() + 1) + \"-01\"),\n      selectedAirport: airports[0],\n      selectedRunway: \"Any Runway\",\n      mapVisible: true,\n      plotVisible: true,\n      mapStyle: \"Road\",\n      disableFetching: false,\n      // Style object for ttf lines. This is just a thin green line style.\n      ttfStyle: new Style({\n        stroke: new Stroke({\n          color: \"#00ff00\",\n          width: 2.5\n        }),\n        image: new Circle({\n          radius: 5,\n          //fill: new Fill({color: [0, 0, 0, 255]}),\n          stroke: new Stroke({\n            color: [0, 0, 0, 0],\n            width: 2\n          })\n        })\n      }),\n      optimalDescentExceedencesStyle: new Style({\n        stroke: new Stroke({\n          color: \"#ff0000\",\n          width: 1.5\n        }),\n        image: new Circle({\n          radius: 5,\n          //fill: new Fill({color: [0, 0, 0, 255]}),\n          stroke: new Stroke({\n            color: [0, 0, 0, 0],\n            width: 2\n          })\n        })\n      })\n    };\n    var navbar = ReactDOM.render( /*#__PURE__*/React.createElement(SignedInNavbar, {\n      filterVisible: false,\n      plotVisible: _this.state.plotVisible,\n      mapVisible: _this.state.mapVisible,\n      activePage: \"ttf\",\n      filterSelected: false,\n      plotSelected: false,\n      mapSelected: false,\n      mapStyle: _this.state.mapStyle,\n      togglePlot: function togglePlot() {\n        return _this.togglePlot();\n      },\n      toggleFilter: function toggleFilter() {\n        return _this.toggleFilter();\n      },\n      toggleMap: function toggleMap() {\n        return _this.toggleMap();\n      },\n      mapSelectChanged: function mapSelectChanged(style) {\n        return _this.mapSelectChanged(style);\n      },\n      waitingUserCount: waitingUserCount,\n      fleetManager: fleetManager,\n      unconfirmedTailsCount: unconfirmedTailsCount,\n      modifyTailsAccess: modifyTailsAccess\n    }), document.querySelector('#navbar')); // https://embed.plnkr.co/plunk/hhEAWk\n\n    map.on('click', function (event) {\n      // https://openlayers.org/en/latest/examples/popup.html\n      // var container = document.getElementById('popup');\n      // var content = document.getElementById('popup-content');\n      // var closer = document.getElementById('popup-closer');\n      closer.onclick = function () {\n        overlay.setPosition(undefined);\n        closer.blur();\n        return false;\n      };\n\n      var coordinate = event.coordinate;\n      var f = map.forEachFeatureAtPixel(event.pixel, function (feature, layer) {\n        return feature;\n      });\n      console.log(f);\n\n      if (f && f.get('type') == 'ttf') {\n        var geometry = f.getGeometry();\n        var coord = geometry.getCoordinates();\n        console.log(\"selected feature \" + f.get('name'));\n        window.open(\"/protected/flight?flight_id=4228\", '_blank').focus();\n      } else {\n        container.style.display = 'none';\n      }\n    });\n    Plotly.newPlot('deviations-plot', [], deviationsPlotlyLayout, plotlyConfig);\n    Plotly.newPlot('alt-plot', [], altitudePlotlyLayout, plotlyConfig);\n    Plotly.newPlot('glide-angle-hist', [], glideAngleHistLayout, plotlyConfig);\n    return _this;\n  }\n\n  _createClass(TTFCard, [{\n    key: \"mapSelectChanged\",\n    value: function mapSelectChanged(style) {\n      for (var i = 0, ii = layers.length; i < ii; ++i) {\n        layers[i].setVisible(styles[i] === style);\n      }\n\n      this.setState({\n        mapStyle: style\n      });\n    }\n  }, {\n    key: \"showMap\",\n    value: function showMap() {\n      if (this.state.mapVisible) return;\n\n      if (!$(\"#map-toggle-button\").hasClass(\"active\")) {\n        $(\"#map-toggle-button\").addClass(\"active\");\n        $(\"#map-toggle-button\").attr(\"aria-pressed\", true);\n      }\n\n      this.state.mapVisible = true;\n      this.setState(this.state);\n      $(\"#map-div\").css(\"height\", \"50%\");\n      $(\"#map\").show();\n      $(\"#map\").css(\"width\", \"100%\");\n    }\n  }, {\n    key: \"hideMap\",\n    value: function hideMap() {\n      if (!this.state.mapVisible) return;\n\n      if ($(\"#map-toggle-button\").hasClass(\"active\")) {\n        $(\"#map-toggle-button\").removeClass(\"active\");\n        $(\"#map-toggle-button\").attr(\"aria-pressed\", false);\n      }\n\n      this.state.mapVisible = false;\n      this.setState(this.state);\n      $(\"#map\").hide();\n      $(\"#map\").css(\"height\", \"0%\");\n    }\n  }, {\n    key: \"toggleMap\",\n    value: function toggleMap() {\n      if (this.state.mapVisible) {\n        this.hideMap();\n      } else {\n        this.showMap();\n      }\n    }\n  }, {\n    key: \"toggleFilter\",\n    value: function toggleFilter() {\n      if (this.state.filterVisible) {\n        this.hideFilter();\n      } else {\n        this.showFilter();\n      }\n    }\n  }, {\n    key: \"ttfToPoints\",\n    value: function ttfToPoints(ttf) {\n      // This will generate a list of points in the appropriate format and save it, so it is only computed once.\n      // This should only ever get called once though so I guess this is unnecessary.\n      if (typeof ttf.points !== 'undefined') return ttf.points;\n      var points = [];\n      ttf.points = points;\n\n      for (var i = 0; i < ttf.lon.length; i++) {\n        var point = fromLonLat([ttf.lon[i], ttf.lat[i]]);\n        points.push(point);\n      }\n\n      return points;\n    }\n  }, {\n    key: \"rangeExtraction\",\n    value: function rangeExtraction(list) {\n      var len = list.length;\n      if (len == 0) return [];\n      var out = [];\n      var i, j;\n\n      for (i = 0; i < len; i = j + 1) {\n        // find end of range\n        for (var j = i + 1; j < len && list[j] == list[j - 1] + 1; j++) {\n          ;\n        }\n\n        j--;\n\n        if (i == j) {\n          // single number\n          out.push([list[i]]);\n        } else {\n          out.push([list[i], list[j]]);\n        }\n      }\n\n      return out;\n    }\n  }, {\n    key: \"rangesToFeatures\",\n    value: function rangesToFeatures(points, ranges) {\n      // Ranges should be a list of ranges generated by rangeExtraction\n      // the ranges generated by list extraction are either ranges (an array, [min, max]) or a single number in an array\n      // [like_this]. We ignore the numbers that are by themselves since they cannot be connected to anything. In the\n      // future perhaps it would be good to display them as dots.\n      var features = [];\n\n      for (var i = 0; i < ranges.length; i++) {\n        var r = ranges[i];\n        if (r.length == 1) continue; // There is no range, just a single number\n\n        var min = r[0];\n        var max = r[1];\n        var rangePoints = []; // This is an inclusive range.\n\n        for (var j = min; j <= max; j++) {\n          rangePoints.push(points[j]);\n        }\n\n        features.push(new Feature({\n          geometry: new LineString(rangePoints)\n        }));\n      }\n\n      return features;\n    }\n  }, {\n    key: \"makeTTFLayers\",\n    value: function makeTTFLayers(ttf) {\n      // This will generate a layer for this ttf if once hasn't been generated before, and add it to the map as a\n      // hidden layer.\n      if (typeof ttf.layer !== 'undefined') return ttf.layer;\n      var points = this.ttfToPoints(ttf); // Create simple layer of the path.\n\n      var trackingPoint = new Feature({\n        geometry: new Point(points[0]),\n        name: 'TrackingPoint'\n      });\n      var features = [new Feature({\n        geometry: new LineString(points),\n        name: ttf.flightId,\n        type: 'ttf',\n        ttf: ttf\n      }), trackingPoint];\n      var layer = new VectorLayer({\n        style: this.getStyle(ttf),\n        source: new VectorSource({\n          features: features\n        })\n      });\n      ttf.layer = layer;\n      map.addLayer(layer);\n      layer.setVisible(false);\n      ttf.enabled = true;\n      return ttf.layer;\n    }\n  }, {\n    key: \"getStyle\",\n    value: function getStyle(ttf) {\n      return new Style({\n        stroke: new Stroke({\n          // Assuming anything past 45 is really bad, so color will get increasingly\n          // red as roll approaches 45\n          color: rollPalette(ttf.maxRoll),\n          width: 2.5\n        }),\n        image: new Circle({\n          radius: 5,\n          //fill: new Fill({color: [0, 0, 0, 255]}),\n          stroke: new Stroke({\n            color: [0, 0, 0, 0],\n            width: 2\n          })\n        })\n      });\n    }\n  }, {\n    key: \"updateDisplay\",\n    value: function updateDisplay() {\n      if (this.state.data != null) {\n        this.plotTTFs();\n        this.plotCharts(this.state.data.ttfs);\n      }\n    }\n  }, {\n    key: \"plotTTFs\",\n    value: function plotTTFs() {\n      var _iterator = _createForOfIteratorHelper(this.state.data.ttfs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var ttf = _step.value;\n          if (this.shouldDisplay(ttf)) this.plotTTF(ttf);else this.hideTTF(ttf);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"plotTTF\",\n    value: function plotTTF(ttf) {\n      this.makeTTFLayers(ttf);\n      var layer = ttf.layer;\n      layer.setVisible(true); // let optimalDescentExceedencesLayer = ttf.optimalDescentExceedencesLayer;\n      // optimalDescentExceedencesLayer.setVisible(true);\n      // let extent = layer.getSource().getExtent();\n      // console.log(extent);\n      // map.getView().fit(extent, map.getSize());\n    }\n  }, {\n    key: \"hideTTF\",\n    value: function hideTTF(ttf) {\n      this.makeTTFLayers(ttf);\n      var layer = ttf.layer;\n      layer.setVisible(false); // let optimalDescentExceedencesLayer = ttf.optimalDescentExceedencesLayer;\n      // optimalDescentExceedencesLayer.setVisible(false);\n    } // setMaximumRoll will move the roll slider to the maximum roll found in the set of ttfs so that\n    // all flights will be displayed\n\n  }, {\n    key: \"plotCharts\",\n    value: function plotCharts(ttfs) {\n      var _this2 = this;\n\n      var setMaximumRoll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      console.log(\"Plotting charts\");\n\n      if (setMaximumRoll) {\n        var minRoll = Math.min.apply(Math, _toConsumableArray(ttfs.map(function (ttf) {\n          return ttf.maxRoll;\n        })));\n        this.onRollSliderChanged(minRoll, true);\n      }\n\n      var max = Math.max.apply(Math, _toConsumableArray(ttfs.map(function (ttf) {\n        return ttf.AltMSL.length;\n      })));\n      var ttfIndex = -1;\n      var curves = ttfs.map(function (ttf) {\n        ttfIndex += 1;\n        var glideAngle = ttf.selfDefinedGlideAngle;\n        var alt = ttf.AltAGL; // This is what applies the roll filter\n\n        if (_this2.shouldDisplay(ttf)) {\n          return {\n            deviations: {\n              name: ttf.flightId,\n              x: ttf.distanceFromRunway,\n              y: ttf.selfDefinedGlidePathDeviations,\n              type: 'scatter',\n              mode: 'lines'\n            },\n            alt: {\n              name: ttf.flightId,\n              x: ttf.distanceFromRunway,\n              y: alt,\n              type: 'scatter',\n              mode: 'lines'\n            },\n            maxGlideAngle: glideAngle,\n            _ttfIndex: ttfIndex\n          };\n        } else return null;\n      }).filter(function (curve) {\n        return curve != null;\n      });\n      var curveMap = {};\n\n      for (var i = 0; i < curves.length; i++) {\n        curveMap[i] = curves[i]._ttfIndex;\n      }\n\n      var deviationsCurves = curves.map(function (x) {\n        return x.deviations;\n      });\n      var devPlot = document.getElementById('deviations-plot');\n      Plotly.newPlot('deviations-plot', deviationsCurves, deviationsPlotlyLayout, this.state.plotlyConfig);\n      console.log(devPlot);\n      var maxGlideAngles = curves.map(function (x) {\n        return x.maxGlideAngle;\n      });\n      var glideAngleTrace = {\n        type: 'histogram',\n        y: maxGlideAngles,\n        ybins: {\n          end: 30,\n          // Math.ceil(Math.max(...maxGlideAngles)),\n          size: 1.0,\n          start: 0 // Math.floor(Math.min(...maxGlideAngles)),\n\n        }\n      };\n      Plotly.newPlot('glide-angle-hist', [glideAngleTrace], glideAngleHistLayout);\n      var this_ = this;\n\n      function onLegendClick(data) {\n        // Disable this single item and re-draw map and charts.\n        ttfs[curveMap[data.curveNumber]].enabled = !ttfs[curveMap[data.curveNumber]].enabled;\n        Plotly.restyle('myDiv', update, [data.curveNumber]);\n        this_.updateDisplay();\n        return true;\n      }\n\n      function onLegendDoubleClick(data) {\n        var _iterator2 = _createForOfIteratorHelper(ttfs),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var ttf = _step2.value;\n            ttf.enabled = false;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        ttfs[curveMap[data.curveNumber]].enabled = true;\n        this_.updateDisplay();\n        return true;\n      } // devPlot.on('plotly_legendclick', onLegendClick);\n\n\n      var altCurves = curves.map(function (x) {\n        return x.alt;\n      });\n      Plotly.newPlot('alt-plot', altCurves, altitudePlotlyLayout, this.state.plotlyConfig);\n      var airport = this.state.selectedAirport;\n      var lat = runways[airport][0]['lat1'];\n      var lon = runways[airport][0]['lon1'];\n      var view = map.getView();\n      view.setCenter(fromLonLat([lon, lat]));\n      view.setZoom(12);\n      map.setView(view);\n    }\n  }, {\n    key: \"getRunwayValue\",\n    value: function getRunwayValue() {\n      var runwayElement = this.state.selectedRunway;\n      if (runwayElement == null) return null;else if (this.state.dataAirport != this.getAirportValue()) return null;else return runwayElement.value;\n    }\n  }, {\n    key: \"getAirportValue\",\n    value: function getAirportValue() {\n      return this.state.selectedAirport;\n    }\n  }, {\n    key: \"shouldDisplay\",\n    value: function shouldDisplay(ttf) {\n      var runway = this.state.selectedRunway;\n      var should = ttf.enabled && (this.state.selectedRunway == null || ['Any Runway', ttf.runway.name].includes(runway)) && this.dateWithinRange(this.parseDate(ttf.flightStartDate), this.state.startDateObject, this.state.endDateObject) && ttf.maxRoll >= this.state.minRoll;\n      return should;\n    } // For parsing dates in the format \"yyyy-mm-dd hh:mm:ss\" where the hh:mm:ss is optional\n\n  }, {\n    key: \"parseDate\",\n    value: function parseDate(dateString) {\n      if (dateString == null) return null;\n      var pieces = dateString.split(\" \");\n      var yyyymmdd = pieces[0].split(\"-\");\n      var year = yyyymmdd[0]; // Minus 1 because dates are zero indexed in javascript\n\n      var month = parseInt(yyyymmdd[1]) - 1;\n      var day = yyyymmdd[2];\n\n      if (pieces.length > 1) {\n        var hhmmss = pieces[1].split(\":\");\n        var hour = hhmmss[0];\n        var minutes = hhmmss[1];\n        var seconds = hhmmss[2];\n        return new Date(year, month, day, hour, minutes, seconds);\n      } else return new Date(year, month, day);\n\n      return new Date(year, month, day);\n    } // These should all be date objects\n\n  }, {\n    key: \"dateWithinRange\",\n    value: function dateWithinRange(date, startDate, endDate) {\n      return startDate <= date && date <= endDate;\n    }\n  }, {\n    key: \"onFetchClicked\",\n    value: function onFetchClicked() {\n      this.setDates();\n      var startDateString = this.state.startDate;\n      var endDateString = this.state.endDate;\n      var airport = this.state.selectedAirport;\n      var runway = this.state.selectedRunway;\n      var submissionData = {\n        startDate: startDateString,\n        endDate: endDateString,\n        airport: airport\n      };\n      var thisTTF = this;\n      var startDate = this.parseDate(startDateString);\n      var endDate = this.parseDate(endDateString); // start and end dates for the data we already have\n      // This won't encounter an error even if either of dataStartDate or dataEndDate is null.\n      // If they're null then they won't get used because this.state.data is also null.\n      // This feels like bad practice though.\n\n      var dataStartDate = this.parseDate(this.state.dataStartDate);\n      var dataEndDate = this.parseDate(this.state.dataEndDate); // This will show TTFs in the specified date range and hide every other TTF.\n      // If the TTFs have already been plotted it will use the previous layer.\n\n      function responseFunction(response) {\n        var ttfs = [];\n\n        for (var i = 0; i < response.ttfs.length; i++) {\n          var _ttf = response.ttfs[i];\n          ttfs.push(_ttf);\n          thisTTF.plotTTF(_ttf);\n        }\n\n        thisTTF.setState({\n          data: response\n        });\n        thisTTF.plotCharts(ttfs, true);\n      }\n\n      this.setState({\n        datesChanged: false\n      }); // If we already have some data, and the date range of that data contains the new date range,\n      // then we don't need to fetch any more data - just turn off layers for data that not within the new range.\n      // We should keep the old dataStartDate and dataEndDate though to preserve the entire range.\n\n      if (this.state.data != null && this.dateWithinRange(startDate, dataStartDate, dataEndDate) && this.dateWithinRange(endDate, dataStartDate, dataEndDate) && airport == this.state.dataAirport) {\n        console.log(\"Used cached data\");\n\n        var _iterator3 = _createForOfIteratorHelper(this.state.data.ttfs),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _ttf2 = _step3.value;\n            _ttf2.enabled = true;\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        this.updateDisplay();\n      } else {\n        // Remove all old layers\n        if (this.state.data != null) {\n          var _iterator4 = _createForOfIteratorHelper(this.state.data.ttfs),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var ttf = _step4.value;\n              map.removeLayer(ttf.layer); // map.removeLayer(ttf.optimalDescentExceedencesLayer);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n\n        this.setState({\n          disableFetching: true\n        }); // Fetch the data.\n\n        $.ajax({\n          type: 'POST',\n          url: '/protected/ttf',\n          data: submissionData,\n          dataType: 'json',\n          success: function success(response) {\n            console.log(\"Fetched response \" + response); // store the dates we have fetched data for\n\n            thisTTF.state.dataAirport = submissionData.airport;\n            thisTTF.state.dataStartDate = submissionData.startDate;\n            thisTTF.state.dataEndDate = submissionData.endDate;\n            thisTTF.setState({\n              disableFetching: false,\n              dataEndDate: submissionData.endDate,\n              dataStartDate: submissionData.startDate\n            });\n            responseFunction(response);\n          },\n          error: function error(jqXHR, textStatus, errorThrown) {\n            console.log(textStatus);\n            console.log(errorThrown);\n            thisTTF.setState({\n              disableFetching: false,\n              datesChanged: false\n            });\n          },\n          async: true\n        });\n      }\n    }\n  }, {\n    key: \"getAirports\",\n    value: function getAirports() {\n      if (this.state.data == null) {\n        console.log(\"This shouldn't get called when this.state.data == null\");\n        return null;\n      } // list of airport IATA codes\n\n\n      var airports = [];\n\n      for (var _i = 0, _Object$entries = Object.entries(this.state.data.airports); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n            name = _Object$entries$_i[0],\n            ap = _Object$entries$_i[1];\n\n        airports.push(ap.iataCode);\n      }\n\n      return airports;\n    }\n  }, {\n    key: \"onAirportFilterChanged\",\n    value: function onAirportFilterChanged(airport) {\n      var iataCode = airport;\n      this.setState({\n        selectedAirport: iataCode,\n        selectedRunway: \"Any Runway\",\n        datesChanged: true\n      });\n    }\n  }, {\n    key: \"onUpdateStartYear\",\n    value: function onUpdateStartYear(year) {\n      this.state.startYear = year;\n      this.setDates();\n      this.forceUpdate();\n    }\n  }, {\n    key: \"onUpdateStartMonth\",\n    value: function onUpdateStartMonth(month) {\n      this.state.startMonth = month;\n      this.setDates();\n      this.forceUpdate();\n    }\n  }, {\n    key: \"onUpdateEndYear\",\n    value: function onUpdateEndYear(year) {\n      this.state.endYear = year;\n      this.setDates();\n      this.forceUpdate();\n    }\n  }, {\n    key: \"onUpdateEndMonth\",\n    value: function onUpdateEndMonth(month) {\n      this.state.endMonth = month;\n      this.setDates();\n      this.forceUpdate();\n    }\n  }, {\n    key: \"setDates\",\n    value: function setDates() {\n      function getDaysInMonth(year, month) {\n        return new Date(year, month, 0).getDate();\n      }\n\n      var endDate;\n      var startDate;\n      this.state.datesChanged = true;\n\n      if (this.state.startMonth < 10) {\n        startDate = \"\" + this.state.startYear + \"-0\" + this.state.startMonth + \"-01\";\n      } else {\n        startDate = \"\" + this.state.startYear + \"-\" + this.state.startMonth + \"-01\";\n      }\n\n      var startDateObject = this.parseDate(startDate);\n      var finalDayOfMonth = getDaysInMonth(this.state.endYear, this.state.endMonth);\n\n      if (this.state.endMonth < 10) {\n        endDate = \"\" + this.state.endYear + \"-0\" + this.state.endMonth + \"-\" + finalDayOfMonth;\n      } else {\n        endDate = \"\" + this.state.endYear + \"-\" + this.state.endMonth + \"-\" + finalDayOfMonth;\n      }\n\n      var endDateObject = this.parseDate(endDate);\n      this.setState({\n        dateChanged: true,\n        endDate: endDate,\n        startDate: startDate,\n        endDateObject: endDateObject,\n        startDateObject: startDateObject\n      });\n    }\n  }, {\n    key: \"onRunwayFilterChanged\",\n    value: function onRunwayFilterChanged(runway) {\n      if (runway == null) {\n        throw \"getRunwayValue returned null even though the onRunwayFilterChanged event handler was called.\";\n      }\n\n      this.state.selectedRunway = runway;\n      this.forceUpdate();\n\n      if (this.state.data != null) {\n        var _iterator5 = _createForOfIteratorHelper(this.state.data.ttfs),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var ttf = _step5.value;\n            if (this.shouldDisplay(ttf)) this.plotTTF(ttf);else this.hideTTF(ttf);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    }\n  }, {\n    key: \"onRollSliderChanged\",\n    value: function onRollSliderChanged(value) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var slider = document.getElementById('rollSlider');\n\n      if (!override) {\n        this.setState({\n          minRoll: slider.value\n        });\n\n        if (this.state.data != null) {\n          this.updateDisplay();\n        }\n      } else {\n        this.setState({\n          minRoll: value\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var runwaySelect;\n\n      if (this.state.data == null) {\n        runwaySelect = /*#__PURE__*/React.createElement(\"div\", null, \" \");\n      } else {\n        var airport = this.state.dataAirport;\n        runwaySelect = /*#__PURE__*/React.createElement(\"div\", null, /*#__PURE__*/React.createElement(\"label\", {\n          htmlFor: \"runway\"\n        }, \"Runway: \"), /*#__PURE__*/React.createElement(Form.Control, {\n          as: \"select\",\n          id: \"runway\",\n          selected: \"Any Runway\",\n          onChange: function onChange() {\n            return _this3.onRunwayFilterChanged();\n          }\n        }, /*#__PURE__*/React.createElement(\"option\", {\n          key: \"Any Runway\"\n        }, \" Any Runway \"), runways[airport].map(function (runway) {\n          return /*#__PURE__*/React.createElement(\"option\", {\n            key: runway.name\n          }, runway.name);\n        })));\n      }\n\n      var runwayList = runways[this.state.selectedAirport].map(function (runway) {\n        return runway.name;\n      });\n      var rollSlider = /*#__PURE__*/React.createElement(RollSlider, {\n        rollSliderMin: 0,\n        rollSliderMax: 45,\n        rollSliderChanged: function rollSliderChanged(val) {\n          return _this3.onRollSliderChanged(val);\n        },\n        rollSliderValue: function rollSliderValue() {\n          return _this3.state.minRoll;\n        }\n      });\n      var turnToFinalHeaderComponents = /*#__PURE__*/React.createElement(TurnToFinalHeaderComponents, {\n        airframes: [],\n        airport: this.state.selectedAirport,\n        airports: airports,\n        airportChange: function airportChange(airport) {\n          return _this3.onAirportFilterChanged(airport);\n        },\n        runway: this.state.selectedRunway,\n        runways: runwayList,\n        runwayChange: function runwayChange(runway) {\n          return _this3.onRunwayFilterChanged(runway);\n        }\n      });\n      var form = /*#__PURE__*/React.createElement(\"div\", null, /*#__PURE__*/React.createElement(TimeHeader, {\n        name: \"Flight Filters\",\n        disabled: this.state.disableFetching,\n        buttonContent: 'Fetch',\n        extraHeaderComponents: turnToFinalHeaderComponents,\n        extraRowComponents: rollSlider,\n        startYear: this.state.startYear,\n        startMonth: this.state.startMonth,\n        endYear: this.state.endYear,\n        endMonth: this.state.endMonth,\n        datesChanged: this.state.datesChanged,\n        dateChange: function dateChange() {\n          return _this3.onFetchClicked();\n        },\n        updateStartYear: function updateStartYear(newStartYear) {\n          return _this3.onUpdateStartYear(newStartYear);\n        },\n        updateStartMonth: function updateStartMonth(newStartMonth) {\n          return _this3.onUpdateStartMonth(newStartMonth);\n        },\n        updateEndYear: function updateEndYear(newEndYear) {\n          return _this3.onUpdateEndYear(newEndYear);\n        },\n        updateEndMonth: function updateEndMonth(newEndMonth) {\n          return _this3.onUpdateEndMonth(newEndMonth);\n        }\n      }), /*#__PURE__*/React.createElement(\"br\", null));\n      return form;\n    }\n  }]);\n\n  return TTFCard;\n}(React.Component);\n\nvar ttfCard = null; //check to see if flights has been defined already. unfortunately\n//the navbar includes flights.js (bad design) for the navbar buttons\n//to toggle flights, etc. So this is a bit of a hack.\n\nttfCard = ReactDOM.render( /*#__PURE__*/React.createElement(TTFCard, null), document.querySelector('#ttf-card'));\nconsole.log(\"rendered ttfCard!\");\nexport { ttfCard };",{"version":3,"names":["React","Component","ReactDOM","Form","map","styles","layers","Colors","overlay","initializeMap","container","content","closer","TimeHeader","TurnToFinalHeaderComponents","SignedInNavbar","paletteAt","paletteGenerator","View","Overlay","Coordinate","fromLonLat","toLonLat","Group","Vector","VectorLayer","VectorSource","Circle","Fill","Icon","Stroke","Style","Draw","Feature","LineString","Point","Filter","Plotly","moment","require","RollSlider","props","min","max","onChange","getValue","textAlign","margin","val","verticalAlign","width","backgroundImage","height","makeRollSlider","rollSliderMin","rollSliderMax","rollSliderChanged","rollSliderValue","rollPalette","plotlyDefaultLayout","title","showlegend","autosize","pad","xaxis","text","font","family","size","color","yaxis","glideAngleHistLayout","bargap","deviationsPlotlyLayout","autorange","range","altitudePlotlyLayout","plotlyConfig","responsive","TTFCard","date","Date","state","dataStartDate","dataEndDate","data","datesChanged","minRoll","startYear","startMonth","endYear","getFullYear","endMonth","getMonth","startDate","startDateObject","parseDate","endDate","String","endDateObject","selectedAirport","airports","selectedRunway","mapVisible","plotVisible","mapStyle","disableFetching","ttfStyle","stroke","image","radius","optimalDescentExceedencesStyle","navbar","render","togglePlot","toggleFilter","toggleMap","style","mapSelectChanged","waitingUserCount","fleetManager","unconfirmedTailsCount","modifyTailsAccess","document","querySelector","on","event","onclick","setPosition","undefined","blur","coordinate","f","forEachFeatureAtPixel","pixel","feature","layer","console","log","get","geometry","getGeometry","coord","getCoordinates","window","open","focus","display","newPlot","i","ii","length","setVisible","setState","$","hasClass","addClass","attr","css","show","removeClass","hide","hideMap","showMap","filterVisible","hideFilter","showFilter","ttf","points","lon","point","lat","push","list","len","out","j","ranges","features","r","rangePoints","ttfToPoints","trackingPoint","name","flightId","type","getStyle","source","addLayer","enabled","maxRoll","plotTTFs","plotCharts","ttfs","shouldDisplay","plotTTF","hideTTF","makeTTFLayers","setMaximumRoll","Math","onRollSliderChanged","AltMSL","ttfIndex","curves","glideAngle","selfDefinedGlideAngle","alt","AltAGL","deviations","x","distanceFromRunway","y","selfDefinedGlidePathDeviations","mode","maxGlideAngle","_ttfIndex","filter","curve","curveMap","deviationsCurves","devPlot","getElementById","maxGlideAngles","glideAngleTrace","ybins","end","start","this_","onLegendClick","curveNumber","restyle","update","updateDisplay","onLegendDoubleClick","altCurves","airport","runways","view","getView","setCenter","setZoom","setView","runwayElement","dataAirport","getAirportValue","value","runway","should","includes","dateWithinRange","flightStartDate","dateString","pieces","split","yyyymmdd","year","month","parseInt","day","hhmmss","hour","minutes","seconds","setDates","startDateString","endDateString","submissionData","thisTTF","responseFunction","response","removeLayer","ajax","url","dataType","success","error","jqXHR","textStatus","errorThrown","async","Object","entries","ap","iataCode","forceUpdate","getDaysInMonth","getDate","finalDayOfMonth","dateChanged","override","slider","runwaySelect","onRunwayFilterChanged","runwayList","rollSlider","turnToFinalHeaderComponents","onAirportFilterChanged","form","onFetchClicked","newStartYear","onUpdateStartYear","newStartMonth","onUpdateStartMonth","newEndYear","onUpdateEndYear","newEndMonth","onUpdateEndMonth","ttfCard"],"sources":["/ngafid/ngafid2.0/src/main/javascript/ttf.js"],"sourcesContent":["import 'bootstrap';\nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Form from \"react-bootstrap/Form\";\n\nimport { map, styles, layers, Colors, overlay, initializeMap, container, content, closer } from \"./map.js\";\nimport { TimeHeader, TurnToFinalHeaderComponents } from \"./time_header.js\";\nimport SignedInNavbar from \"./signed_in_navbar.js\";\nimport { paletteAt, paletteGenerator } from \"./map_utils.js\";\n\nimport View from 'ol/View';\nimport Overlay from 'ol/Overlay';\nimport Coordinate from 'ol/coordinate';\nimport {fromLonLat, toLonLat} from 'ol/proj.js';\nimport {Group, Vector as VectorLayer} from 'ol/layer.js';\nimport {Vector as VectorSource} from 'ol/source.js';\nimport {Circle, Fill, Icon, Stroke, Style} from 'ol/style.js';\nimport Draw from 'ol/interaction/Draw.js';\n\nimport Feature from 'ol/Feature.js';\nimport LineString from 'ol/geom/LineString.js';\nimport Point from 'ol/geom/Point.js';\nimport { Filter } from './filter.js';\n\nimport Plotly from 'plotly.js';\n\nvar moment = require('moment');\n\ninitializeMap();\n\nclass RollSlider extends React.Component {\n    constructor(props) {\n        super(props);\n    }\n\n    makeRollSlider(min, max, onChange, getValue) {\n        \n        return (\n            <div className=\"col-auto\" style={{textAlign: 'center', margin: 'auto'}}\n                  >\n                Minimum Roll Value = {getValue()}&deg;  <br/>\n                {min}&deg; <input  id=\"rollSlider\" type=\"range\" min={min} max={max} value={getValue()} className=\"slider\" id=\"rollSlider\" onInput={(val) => onChange(val)}\n                        style={{margin: 'auto', verticalAlign: 'middle'}}/> {max}&deg;\n                <br/>\n                <div style={{ margin: \"auto\", width: \"83%\", backgroundImage: \"linear-gradient(90deg, rgb(0, 255, 0), 55%, rgb(255, 255, 0), 66%, rgb(255, 0, 0))\", height: \"4px\" }}></div>\n            </div>\n        );\n    }\n\n    render() {\n        return this.makeRollSlider(this.props.rollSliderMin, this.props.rollSliderMax, this.props.rollSliderChanged, this.props.rollSliderValue)\n    }\n}\n\nlet rollPalette = paletteGenerator([[0, 255, 0], [255, 255, 0], [255, 0, 0]], [0, 26, 30]);\n\n// Default chart layout, used for empty charts\nconst plotlyDefaultLayout = {\n    title: 'Chart',\n    showlegend: true,\n    autosize: true,\n    margin: {\n        pad: 2\n    },\n    xaxis: {\n        title: {\n            text: 'Time (Seconds)',\n            font: {\n                family: 'sans serif',\n                size: 18,\n                color: '#000000'\n            }\n        },\n    },\n    yaxis: {\n        title: {\n            text: 'Self Defined Glide Angle',\n            font: {\n                family: 'sans serif',\n                size: 18,\n                color: '#000000'\n            }\n        }\n    }\n};\nconst glideAngleHistLayout = {\n    title: 'Histogram of Glide Path Angles',\n    bargap: 0.05,\n    showlegend: true,\n    autosize: true,\n    margin: {\n        pad: 10\n    },\n    xaxis: {title: 'Frequency'},\n    yaxis: {title: 'Glide Path Angle'}\n};\nconst deviationsPlotlyLayout = {\n    title: 'Glide Path Deviations',\n    showlegend: true,\n    autosize: true,\n    margin: {\n        pad: 2\n    },\n    xaxis: {\n        title: {\n            text: 'Distance from Runway (ft.)',\n            font: {\n                family: 'sans serif',\n                size: 18,\n                color: '#000000'\n            }\n        },\n        autorange: \"reversed\"\n    },\n    yaxis: {\n        title: {\n            text: 'Distance above Glidepath (ft.)',\n            font: {\n                family: 'sans serif',\n                size: 18,\n                color: '#000000'\n            },\n            range: [-100, 100]\n        }\n    }\n};\nconst altitudePlotlyLayout = {\n    title: 'Altitude vs. Distance to Runway',\n    showlegend: true,\n    autosize: true,\n    margin: {\n        pad: 2\n    },\n    xaxis: {\n        title: {\n            text: 'Distance from Runway (ft.)',\n            font: {\n                family: 'sans serif',\n                size: 18,\n                color: '#000000'\n            }\n        },\n        autorange: \"reversed\"\n    },\n    yaxis: {\n        title: {\n            text: 'Alitude (AGL) (ft.)',\n            font: {\n                family: 'sans serif',\n                size: 18,\n                color: '#000000'\n            }\n        }\n    }\n};\nconst plotlyConfig = {responsive: true};\n\nclass TTFCard extends React.Component {\n    constructor(props) {\n        super(props);\n        var date = new Date();\n        this.state = {\n            // The start of the date range that this.state.data corresponds to.\n            // This will be null if and only if this.state.data is null\n            dataStartDate: null,\n\n            // The end of the date range that this.state.data corresponds to.\n            // This will be null if and only if this.state.data is null\n            dataEndDate: null,\n\n            // Data is an object containing the following information:\n            //     data = {\n            //         airports: [ <list of airports that appear in the ttf list> ],\n            //         ttfs: [ <list of turn to final objects> ],\n            //     }\n            // The turn to final objects are defined in the org.ngafid.flights.TurnToFinal::jsonify method.\n            data: null,\n\n            datesChanged: true,\n\n            minRoll: 25.0,\n\n            startYear: 2000,\n            startMonth: 1,\n            endYear: date.getFullYear(),\n            endMonth: date.getMonth() + 1,\n            startDate: \"2000-01-01\",\n            startDateObject: this.parseDate(\"2000-01-01\"),\n            endDate: new String(date.getFullYear()) + \"-\" + (date.getMonth() + 1) + \"-01\",\n            endDateObject: this.parseDate(new String(date.getFullYear()) + \"-\" + (date.getMonth() + 1) + \"-01\"),\n\n            selectedAirport: airports[0],\n            selectedRunway: \"Any Runway\",\n            mapVisible: true,\n            plotVisible: true,\n            mapStyle: \"Road\",\n            disableFetching: false,\n            // Style object for ttf lines. This is just a thin green line style.\n            ttfStyle:\n                new Style({\n                    stroke: new Stroke({\n                        color: \"#00ff00\",\n                        width: 2.5\n                    }),\n                    image: new Circle({\n                        radius: 5,\n                        //fill: new Fill({color: [0, 0, 0, 255]}),\n                        stroke: new Stroke({\n                            color: [0, 0, 0, 0],\n                            width: 2\n                        })\n                    })\n                }),\n            optimalDescentExceedencesStyle:\n                new Style({\n                     stroke: new Stroke({\n                         color: \"#ff0000\",\n                         width: 1.5\n                     }),\n                     image: new Circle({\n                         radius: 5,\n                         //fill: new Fill({color: [0, 0, 0, 255]}),\n                         stroke: new Stroke({\n                             color: [0, 0, 0, 0],\n                             width: 2\n                         })\n                     })\n                }),\n        };\n\n        var navbar = ReactDOM.render(\n            <SignedInNavbar\n                                 filterVisible={false}\n                                 plotVisible={this.state.plotVisible}\n                                 mapVisible={this.state.mapVisible}\n                                 activePage=\"ttf\"\n                                 filterSelected={false}\n                                 plotSelected={false}\n                                 mapSelected={false}\n                                 mapStyle={this.state.mapStyle}\n                                 togglePlot={() => this.togglePlot()}\n                                 toggleFilter={() => this.toggleFilter()}\n                                 toggleMap={() => this.toggleMap()}\n                                 mapSelectChanged={(style) => this.mapSelectChanged(style)}\n                                 waitingUserCount={waitingUserCount}\n                                 fleetManager={fleetManager}\n                                 unconfirmedTailsCount={unconfirmedTailsCount}\n                                 modifyTailsAccess={modifyTailsAccess}/>,\n            document.querySelector('#navbar')\n        );\n\n        // https://embed.plnkr.co/plunk/hhEAWk\n        map.on('click', function(event) {\n            // https://openlayers.org/en/latest/examples/popup.html\n            // var container = document.getElementById('popup');\n            // var content = document.getElementById('popup-content');\n            // var closer = document.getElementById('popup-closer');\n\n            closer.onclick = function() {\n                overlay.setPosition(undefined);\n                closer.blur();\n                return false;\n            };\n\n            var coordinate = event.coordinate;\n            var f = map.forEachFeatureAtPixel(event.pixel, function(feature, layer) { return feature; });\n            console.log(f);\n            if (f && f.get('type') == 'ttf') {\n                var geometry = f.getGeometry();\n                var coord = geometry.getCoordinates();\n                console.log(\"selected feature \" + f.get('name'));\n                window.open(\"/protected/flight?flight_id=4228\", '_blank').focus();\n            } else {\n                container.style.display = 'none';\n            }\n        });\n\n        Plotly.newPlot('deviations-plot', [], deviationsPlotlyLayout, plotlyConfig);\n        Plotly.newPlot('alt-plot', [], altitudePlotlyLayout, plotlyConfig);\n        Plotly.newPlot('glide-angle-hist', [], glideAngleHistLayout, plotlyConfig);\n    }\n\n    mapSelectChanged(style) {\n        for (var i = 0, ii = layers.length; i < ii; ++i) {\n            layers[i].setVisible(styles[i] === style);\n        }\n\n        this.setState({mapStyle: style});\n    }\n\n    showMap() {\n        if (this.state.mapVisible) return;\n\n        if ( !$(\"#map-toggle-button\").hasClass(\"active\") ) {\n            $(\"#map-toggle-button\").addClass(\"active\");\n            $(\"#map-toggle-button\").attr(\"aria-pressed\", true);\n        }\n\n        this.state.mapVisible = true;\n        this.setState(this.state);\n\n        $(\"#map-div\").css(\"height\", \"50%\");\n        $(\"#map\").show();\n\n        $(\"#map\").css(\"width\", \"100%\");\n\n    }\n\n    hideMap() {\n        if (!this.state.mapVisible) return;\n\n        if ( $(\"#map-toggle-button\").hasClass(\"active\") ) {\n            $(\"#map-toggle-button\").removeClass(\"active\");\n            $(\"#map-toggle-button\").attr(\"aria-pressed\", false);\n        }\n\n        this.state.mapVisible = false;\n        this.setState(this.state);\n\n        $(\"#map\").hide();\n\n        $(\"#map\").css(\"height\", \"0%\");\n    }\n\n    toggleMap() {\n        if (this.state.mapVisible) {\n            this.hideMap();\n        } else {\n            this.showMap();\n        }\n    }\n\n    toggleFilter() {\n        if (this.state.filterVisible) {\n            this.hideFilter();\n        } else {\n            this.showFilter();\n        }\n    }\n\n    ttfToPoints(ttf) {\n        // This will generate a list of points in the appropriate format and save it, so it is only computed once.\n        // This should only ever get called once though so I guess this is unnecessary.\n        if (typeof ttf.points !== 'undefined')\n            return ttf.points;\n\n        var points = [];\n        ttf.points = points;\n\n        for (var i = 0; i < ttf.lon.length; i++) {\n            var point = fromLonLat([ttf.lon[i], ttf.lat[i]]);\n            points.push(point);\n        }\n\n        return points;\n    }\n\n    rangeExtraction(list) {\n        var len = list.length;\n        if (len == 0) return [];\n\n        var out = [];\n        var i, j;\n\n        for (i = 0; i < len; i = j + 1) {\n            // find end of range\n            for (var j = i + 1; j < len && list[j] == list[j-1] + 1; j++);\n            j--;\n\n            if (i == j) {\n                // single number\n                out.push([list[i]]);\n            } else {\n                out.push([list[i], list[j]]);\n            }\n        }\n\n        return out;\n    }\n\n    rangesToFeatures(points, ranges) {\n        // Ranges should be a list of ranges generated by rangeExtraction\n        // the ranges generated by list extraction are either ranges (an array, [min, max]) or a single number in an array\n        // [like_this]. We ignore the numbers that are by themselves since they cannot be connected to anything. In the\n        // future perhaps it would be good to display them as dots.\n        var features = [];\n        for (var i = 0; i < ranges.length; i++) {\n            let r = ranges[i];\n            if (r.length == 1) continue; // There is no range, just a single number\n\n            let min = r[0];\n            let max = r[1];\n            let rangePoints = [];\n\n            // This is an inclusive range.\n            for (var j = min; j <= max; j++)\n                rangePoints.push(points[j]);\n\n            features.push(new Feature({\n                geometry: new LineString(rangePoints)\n            }));\n        }\n        return features;\n    }\n\n    makeTTFLayers(ttf) {\n        // This will generate a layer for this ttf if once hasn't been generated before, and add it to the map as a\n        // hidden layer.\n        if (typeof ttf.layer !== 'undefined')\n            return ttf.layer;\n\n        var points = this.ttfToPoints(ttf);\n\n        // Create simple layer of the path.\n        let trackingPoint =\n            new Feature({\n                geometry : new Point(points[0]),\n                name: 'TrackingPoint'\n            });\n        var features = [\n            new Feature({\n                geometry: new LineString(points),\n                name: ttf.flightId,\n                type: 'ttf',\n                ttf: ttf\n            }),\n            trackingPoint\n        ];\n\n        let layer = new VectorLayer({\n            style: this.getStyle(ttf),\n            source : new VectorSource({\n                features: features,\n            }),\n        });\n\n        ttf.layer = layer;\n        map.addLayer(layer);\n        layer.setVisible(false);\n        ttf.enabled = true;\n        return ttf.layer;\n    }\n\n    getStyle(ttf) {\n        return new Style({\n            stroke: new Stroke({\n                // Assuming anything past 45 is really bad, so color will get increasingly\n                // red as roll approaches 45\n                color: rollPalette(ttf.maxRoll),\n                width: 2.5\n            }),\n            image: new Circle({\n                radius: 5,\n                //fill: new Fill({color: [0, 0, 0, 255]}),\n                stroke: new Stroke({\n                    color: [0, 0, 0, 0],\n                    width: 2\n                })\n            })\n        })\n    }\n\n    updateDisplay() {\n        if (this.state.data != null) {\n            this.plotTTFs();\n            this.plotCharts(this.state.data.ttfs) \n        }\n    }\n\n    plotTTFs() {\n        for (const ttf of this.state.data.ttfs) {\n            if (this.shouldDisplay(ttf))\n                this.plotTTF(ttf);\n            else\n                this.hideTTF(ttf);\n        }\n    }\n    plotTTF(ttf) {\n        this.makeTTFLayers(ttf);\n\n        let layer = ttf.layer;\n        layer.setVisible(true);\n\n        // let optimalDescentExceedencesLayer = ttf.optimalDescentExceedencesLayer;\n        // optimalDescentExceedencesLayer.setVisible(true);\n\n        // let extent = layer.getSource().getExtent();\n        // console.log(extent);\n        // map.getView().fit(extent, map.getSize());\n    }\n\n    hideTTF(ttf) {\n        this.makeTTFLayers(ttf);\n        let layer = ttf.layer;\n        layer.setVisible(false);\n\n        // let optimalDescentExceedencesLayer = ttf.optimalDescentExceedencesLayer;\n        // optimalDescentExceedencesLayer.setVisible(false);\n    }\n\n    // setMaximumRoll will move the roll slider to the maximum roll found in the set of ttfs so that\n    // all flights will be displayed\n    plotCharts(ttfs, setMaximumRoll = false) {\n        console.log(\"Plotting charts\");\n        if (setMaximumRoll) {\n            let minRoll = Math.min(...ttfs.map(ttf => ttf.maxRoll));\n            this.onRollSliderChanged(minRoll, true);\n        }\n\n        let max = Math.max(...ttfs.map(ttf => ttf.AltMSL.length));\n        let ttfIndex = -1;\n        let curves = ttfs\n            .map(ttf => {\n                ttfIndex += 1;\n                let glideAngle = ttf.selfDefinedGlideAngle;\n                let alt = ttf.AltAGL;\n\n                // This is what applies the roll filter\n                if (this.shouldDisplay(ttf)) {\n                    return { deviations: { name: ttf.flightId, x: ttf.distanceFromRunway, y: ttf.selfDefinedGlidePathDeviations, type: 'scatter', mode: 'lines' },\n                             alt: { name: ttf.flightId, x: ttf.distanceFromRunway, y: alt, type: 'scatter', mode: 'lines' },\n                             maxGlideAngle: glideAngle, _ttfIndex: ttfIndex };\n                } else\n                    return null;\n            })\n            .filter(curve => curve != null);\n        let curveMap = {};\n        for (var i = 0; i < curves.length; i++) {\n            curveMap[i] = curves[i]._ttfIndex;\n        }\n        let deviationsCurves = curves.map(x => x.deviations);\n        \n        let devPlot = document.getElementById('deviations-plot');\n        Plotly.newPlot('deviations-plot', deviationsCurves, deviationsPlotlyLayout, this.state.plotlyConfig);\n        console.log(devPlot);\n\n        let maxGlideAngles = curves.map(x => x.maxGlideAngle);\n        var glideAngleTrace = {\n            type: 'histogram',\n            y: maxGlideAngles,\n            ybins: {\n                end: 30, // Math.ceil(Math.max(...maxGlideAngles)),\n                size: 1.0,\n                start: 0, // Math.floor(Math.min(...maxGlideAngles)),\n            }\n        };\n\n        Plotly.newPlot('glide-angle-hist', [glideAngleTrace], glideAngleHistLayout);\n        let this_ = this;\n        function onLegendClick(data) {\n            // Disable this single item and re-draw map and charts.\n            ttfs[curveMap[data.curveNumber]].enabled = !ttfs[curveMap[data.curveNumber]].enabled;\n            Plotly.restyle('myDiv', update,[data.curveNumber]);\n            this_.updateDisplay();\n            return true;\n        }\n\n        function onLegendDoubleClick(data) {\n            for (const ttf of ttfs) {\n                ttf.enabled = false;\n            }\n            ttfs[curveMap[data.curveNumber]].enabled = true;\n            this_.updateDisplay();\n            return true;\n        }\n\n        // devPlot.on('plotly_legendclick', onLegendClick);\n\n        let altCurves = curves.map(x => x.alt);\n        Plotly.newPlot('alt-plot', altCurves, altitudePlotlyLayout, this.state.plotlyConfig);\n\n        let airport = this.state.selectedAirport;\n        let lat = runways[airport][0]['lat1'];\n        let lon = runways[airport][0]['lon1'];\n        let view = map.getView();\n        view.setCenter(fromLonLat([lon, lat]));\n        view.setZoom(12);\n        map.setView(view);\n    }\n\n    getRunwayValue() {\n        let runwayElement = this.state.selectedRunway;\n        if (runwayElement == null)\n            return null;\n        else if (this.state.dataAirport != this.getAirportValue())\n            return null;\n        else\n            return runwayElement.value;\n    }\n\n    getAirportValue() {\n        return this.state.selectedAirport;\n    }\n\n    shouldDisplay(ttf) {\n        let runway = this.state.selectedRunway;\n        let should = ttf.enabled && (this.state.selectedRunway == null || ['Any Runway', ttf.runway.name].includes(runway))\n                && this.dateWithinRange(this.parseDate(ttf.flightStartDate), this.state.startDateObject, this.state.endDateObject)\n                && ttf.maxRoll >= this.state.minRoll;\n        return should;\n    }\n\n    // For parsing dates in the format \"yyyy-mm-dd hh:mm:ss\" where the hh:mm:ss is optional\n    parseDate(dateString) {\n        if (dateString == null) return null;\n        var pieces = dateString.split(\" \");\n        var yyyymmdd = pieces[0].split(\"-\");\n        var year = yyyymmdd[0];\n        // Minus 1 because dates are zero indexed in javascript\n        var month = parseInt(yyyymmdd[1]) - 1;\n        var day = yyyymmdd[2];\n\n        if (pieces.length > 1) {\n            var hhmmss = pieces[1].split(\":\");\n            var hour = hhmmss[0];\n            var minutes = hhmmss[1];\n            var seconds = hhmmss[2];\n\n            return new Date(year, month, day, hour, minutes, seconds);\n        } else\n            return new Date(year, month, day);\n\n        return new Date(year, month, day);\n    }\n    // These should all be date objects\n    dateWithinRange(date, startDate, endDate) {\n        return startDate <= date && date <= endDate;\n    }\n\n    onFetchClicked() {\n        this.setDates();\n        var startDateString = this.state.startDate;\n        var endDateString = this.state.endDate;\n        var airport = this.state.selectedAirport;\n        var runway = this.state.selectedRunway;\n\n        var submissionData = {\n            startDate: startDateString,\n            endDate: endDateString,\n            airport: airport,\n        };\n        var thisTTF = this;\n\n        var startDate = this.parseDate(startDateString);\n        var endDate = this.parseDate(endDateString);\n\n        // start and end dates for the data we already have\n        // This won't encounter an error even if either of dataStartDate or dataEndDate is null.\n        // If they're null then they won't get used because this.state.data is also null.\n        // This feels like bad practice though.\n        var dataStartDate = this.parseDate(this.state.dataStartDate);\n        var dataEndDate = this.parseDate(this.state.dataEndDate);\n\n        // This will show TTFs in the specified date range and hide every other TTF.\n        // If the TTFs have already been plotted it will use the previous layer.\n        function responseFunction(response) {\n            var ttfs = [];\n            for (var i = 0; i < response.ttfs.length; i++) {\n                let ttf = response.ttfs[i];\n\n                ttfs.push(ttf);\n                thisTTF.plotTTF(ttf);\n            }\n\n            thisTTF.setState({data: response})\n            thisTTF.plotCharts(ttfs, true);\n        }\n\n        this.setState({ datesChanged: false })\n\n        // If we already have some data, and the date range of that data contains the new date range,\n        // then we don't need to fetch any more data - just turn off layers for data that not within the new range.\n        // We should keep the old dataStartDate and dataEndDate though to preserve the entire range.\n        if (this.state.data != null &&\n            this.dateWithinRange(startDate, dataStartDate, dataEndDate) &&\n            this.dateWithinRange(endDate,   dataStartDate, dataEndDate) &&\n            airport == this.state.dataAirport) {\n            console.log(\"Used cached data\");\n            for (const ttf of this.state.data.ttfs) {\n                ttf.enabled = true;\n            }\n            this.updateDisplay();\n        } else {\n            // Remove all old layers\n            if (this.state.data != null) {\n                for (var ttf of this.state.data.ttfs) {\n                    map.removeLayer(ttf.layer);\n                    // map.removeLayer(ttf.optimalDescentExceedencesLayer);\n                }\n            }\n            this.setState({disableFetching: true})\n\n            // Fetch the data.\n            $.ajax({\n                type: 'POST',\n                url: '/protected/ttf',\n                data : submissionData,\n                dataType : 'json',\n                success : function(response) {\n                    console.log(\"Fetched response \" + response);\n\n                    // store the dates we have fetched data for\n                    thisTTF.state.dataAirport = submissionData.airport;\n                    thisTTF.state.dataStartDate = submissionData.startDate;\n                    thisTTF.state.dataEndDate = submissionData.endDate;\n\n                    thisTTF.setState({disableFetching: false, dataEndDate: submissionData.endDate, dataStartDate: submissionData.startDate})\n                    responseFunction(response);\n                },\n                error : function(jqXHR, textStatus, errorThrown) {\n                    console.log(textStatus);\n                    console.log(errorThrown);\n                    thisTTF.setState({disableFetching: false, datesChanged: false,})\n                },\n                async: true\n            });\n        }\n    }\n\n    getAirports() {\n        if (this.state.data == null) {\n            console.log(\"This shouldn't get called when this.state.data == null\");\n            return null;\n        }\n\n        // list of airport IATA codes\n        var airports = [];\n\n        for (let [name, ap] of Object.entries(this.state.data.airports)) {\n            airports.push(ap.iataCode);\n        }\n\n        return airports;\n    }\n\n    onAirportFilterChanged(airport) {\n        let iataCode = airport;\n        this.setState({selectedAirport: iataCode, selectedRunway: \"Any Runway\", datesChanged: true,});\n    }\n\n    onUpdateStartYear(year) {\n        this.state.startYear = year;\n        this.setDates();\n        this.forceUpdate();\n    }\n\n    onUpdateStartMonth(month) {\n        this.state.startMonth = month;\n        this.setDates();\n        this.forceUpdate();\n    }\n\n    onUpdateEndYear(year) {\n        this.state.endYear = year;\n        this.setDates();\n        this.forceUpdate();\n    }\n\n    onUpdateEndMonth(month) {\n        this.state.endMonth = month;\n        this.setDates();\n        this.forceUpdate();\n    }\n\n    setDates() {\n        function getDaysInMonth(year, month) {\n            return new Date(year, month, 0).getDate()\n        }\n        let endDate;\n        let startDate;\n\n        this.state.datesChanged = true;\n        if (this.state.startMonth < 10) {\n            startDate = \"\" + this.state.startYear + \"-0\" + this.state.startMonth + \"-01\";\n        } else {\n            startDate = \"\" + this.state.startYear + \"-\" + this.state.startMonth + \"-01\";\n        }\n        let startDateObject = this.parseDate(startDate)\n        let finalDayOfMonth = getDaysInMonth(this.state.endYear, this.state.endMonth)\n        if (this.state.endMonth < 10) {\n            endDate = \"\" + this.state.endYear + \"-0\" + this.state.endMonth + \"-\" + finalDayOfMonth;\n        } else {\n            endDate = \"\" + this.state.endYear + \"-\" + this.state.endMonth + \"-\" + finalDayOfMonth;\n        }\n        let endDateObject = this.parseDate(endDate);\n\n        this.setState({\n            dateChanged: true,\n            endDate: endDate,\n            startDate: startDate,\n            endDateObject: endDateObject,\n            startDateObject: startDateObject\n        });\n\n    }\n\n    onRunwayFilterChanged(runway) {\n        if (runway == null) {\n            throw \"getRunwayValue returned null even though the onRunwayFilterChanged event handler was called.\"\n        }\n\n        this.state.selectedRunway = runway;\n        this.forceUpdate();\n\n        if (this.state.data != null)\n            for (const ttf of this.state.data.ttfs) {\n                if (this.shouldDisplay(ttf))\n                    this.plotTTF(ttf);\n                else\n                    this.hideTTF(ttf);\n        }\n\n    }\n\n    onRollSliderChanged(value, override=false) {\n        let slider = document.getElementById('rollSlider')\n        if (!override) {\n            this.setState({minRoll: slider.value});\n            if (this.state.data != null) {\n                this.updateDisplay();\n            }\n        } else {\n            this.setState({minRoll: value});\n        }\n    }\n\n    \n\n    render() {\n        let runwaySelect;\n\n        if (this.state.data == null) {\n            runwaySelect = ( <div> </div> );\n        } else {\n            let airport = this.state.dataAirport;\n            runwaySelect = (\n                <div>\n                    <label htmlFor=\"runway\">Runway: </label>\n                    <Form.Control as=\"select\" id=\"runway\" selected=\"Any Runway\" onChange={()=>this.onRunwayFilterChanged()}>\n                        <option key=\"Any Runway\"> Any Runway </option>\n                        {\n                            runways[airport].map(runway => ( <option key={runway.name}>{runway.name}</option> ))\n                        }\n                    </Form.Control>\n                </div>\n            );\n        }\n        let runwayList = runways[this.state.selectedAirport].map(runway => runway.name);\n        let rollSlider =\n            <RollSlider\n                 rollSliderMin={0}\n                 rollSliderMax={45}\n                 rollSliderChanged={(val) => this.onRollSliderChanged(val)}\n                 rollSliderValue={() => this.state.minRoll}\n                />\n        let turnToFinalHeaderComponents =\n            <TurnToFinalHeaderComponents\n                 airframes={[]}\n                 airport={this.state.selectedAirport}\n                 airports={airports}\n                 airportChange={(airport) => this.onAirportFilterChanged(airport)}\n                 runway={this.state.selectedRunway}\n                 runways={runwayList}\n                 runwayChange={(runway) => this.onRunwayFilterChanged(runway)}/>\n\n        let form = (\n            <div>\n                <TimeHeader\n                    name=\"Flight Filters\"\n                    disabled={this.state.disableFetching}\n                    buttonContent={'Fetch'}\n                    extraHeaderComponents={turnToFinalHeaderComponents}\n                    extraRowComponents={rollSlider}\n                    startYear={this.state.startYear}\n                    startMonth={this.state.startMonth}\n                    endYear={this.state.endYear}\n                    endMonth={this.state.endMonth}\n                    datesChanged={this.state.datesChanged}\n                    dateChange={() => this.onFetchClicked()}\n                    updateStartYear={(newStartYear) => this.onUpdateStartYear(newStartYear)}\n                    updateStartMonth={(newStartMonth) => this.onUpdateStartMonth(newStartMonth)}\n                    updateEndYear={(newEndYear) => this.onUpdateEndYear(newEndYear)}\n                    updateEndMonth={(newEndMonth) => this.onUpdateEndMonth(newEndMonth)}/>\n                <br/>\n            </div>\n        );\n\n        return form;\n    }\n}\n\nlet ttfCard = null;\n//check to see if flights has been defined already. unfortunately\n//the navbar includes flights.js (bad design) for the navbar buttons\n//to toggle flights, etc. So this is a bit of a hack.\nttfCard = ReactDOM.render(\n    <TTFCard />,\n    document.querySelector('#ttf-card')\n);\n\nconsole.log(\"rendered ttfCard!\");\n\nexport { ttfCard };\n"],"mappings":"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"}]}